#include <stdio.h>

// Constantes para o número de casas a mover
const int TORRE_CASAS = 3;
const int BISPO_CASAS_VERTICAL = 2;
const int BISPO_CASAS_HORIZONTAL = 2;
const int RAINHA_CASAS = 3;
const int CAVALO_CASAS_CIMA = 2;
const int CAVALO_CASAS_DIREITA = 1;

/*
 * Função recursiva para mover a Torre para cima.
 * Imprime "Cima" a cada casa movida.
 * Parâmetro: casas_restantes - quantas casas ainda faltam mover.
 */
void moverTorreCima(int casas_restantes) {
    if (casas_restantes == 0) {
        return; // Caso base: nenhuma casa para mover
    }
    printf("Cima\n");
    moverTorreCima(casas_restantes - 1); // Chamada recursiva para próxima casa
}

/*
 * Função recursiva para mover a Torre para a direita.
 * Imprime "Direita" a cada casa movida.
 * Parâmetro: casas_restantes - quantas casas ainda faltam mover.
 */
void moverTorreDireita(int casas_restantes) {
    if (casas_restantes == 0) {
        return;
    }
    printf("Direita\n");
    moverTorreDireita(casas_restantes - 1);
}

/*
 * Função recursiva para mover a Rainha para cima.
 * Imprime "Cima" a cada casa movida.
 */
void moverRainhaCima(int casas_restantes) {
    if (casas_restantes == 0) {
        return;
    }
    printf("Cima\n");
    moverRainhaCima(casas_restantes - 1);
}

/*
 * Função recursiva para mover a Rainha para a direita.
 * Imprime "Direita" a cada casa movida.
 */
void moverRainhaDireita(int casas_restantes) {
    if (casas_restantes == 0) {
        return;
    }
    printf("Direita\n");
    moverRainhaDireita(casas_restantes - 1);
}

/*
 * Função recursiva para mover o Bispo na diagonal.
 * Utiliza loops aninhados para simular o movimento diagonal:
 * - Loop externo para o movimento vertical (para cima)
 * - Loop interno para o movimento horizontal (para a direita)
 * Imprime "Cima" e "Direita" para cada casa percorrida.
 * Parâmetros:
 *   casas_vertical - número de casas para mover verticalmente
 *   casas_horizontal - número de casas para mover horizontalmente
 */
void moverBispoDiagonal(int casas_vertical, int casas_horizontal) {
    // Loop externo: movimento vertical (para cima)
    for (int i = 0; i < casas_vertical; i++) {
        printf("Cima\n");
        // Loop interno: movimento horizontal (para a direita)
        for (int j = 0; j < casas_horizontal; j++) {
            printf("Direita\n");
        }
    }
}

/*
 * Função recursiva para mover o Bispo na diagonal,
 * chamando a função com decremento para simular recursividade.
 * Aqui, a recursividade controla o movimento vertical,
 * enquanto o loop interno controla o movimento horizontal.
 */
void moverBispoRecursivo(int casas_vertical, int casas_horizontal) {
    if (casas_vertical == 0) {
        return; // Caso base
    }
    printf("Cima\n");
    // Loop interno para movimento horizontal
    for (int j = 0; j < casas_horizontal; j++) {
        printf("Direita\n");
    }
    // Chamada recursiva para próxima casa vertical
    moverBispoRecursivo(casas_vertical - 1, casas_horizontal);
}

/*
 * Função recursiva para mover a Rainha na diagonal (cima-direita).
 * Imprime "Cima" e "Direita" a cada casa.
 * Parâmetro: casas_restantes - quantas casas ainda faltam mover na diagonal.
 */
void moverRainhaDiagonal(int casas_restantes) {
    if (casas_restantes == 0) {
        return;
    }
    printf("Cima\n");
    printf("Direita\n");
    moverRainhaDiagonal(casas_restantes - 1);
}

/*
 * Função para mover o Cavalo em "L" para cima e para a direita,
 * usando loops aninhados complexos com múltiplas variáveis e controle de fluxo.
 * O Cavalo se move duas casas para cima e uma para a direita.
 * Parâmetros:
 *   casas_cima - número de casas para mover para cima
 *   casas_direita - número de casas para mover para a direita
 */
void moverCavaloLoopsComplexos(int casas_cima, int casas_direita) {
    int movimentos_cima = 0;
    int movimentos_direita = 0;

    // Loop externo controla o movimento para cima
    for (int i = 0; i < casas_cima + 2; i++) { // +2 para controle extra e demonstração de break/continue
        if (movimentos_cima >= casas_cima) {
            // Se já moveu o suficiente para cima, pula para o próximo passo
            break;
        }

        // Condição para pular uma iteração arbitrária (exemplo de continue)
        if (i == 1) {
            i++; // Incrementa para evitar loop infinito
            continue; // Pula a iteração quando i == 1
        }

        printf("Cima\n");
        movimentos_cima++;

        // Loop interno controla o movimento para a direita
        for (int j = 0; j < casas_direita + 2; j++) { // +2 para controle extra
            if (movimentos_direita >= casas_direita) {
                break; // Sai do loop interno se já moveu o suficiente para a direita
            }

            // Exemplo de condição para pular uma iteração
            if (j == 0) {
                j++; // Incrementa para evitar loop infinito
                continue; // Pula a primeira iteração do loop interno
            }

            printf("Direita\n");
            movimentos_direita++;
        }
    }
}

int main() {
    // Movimentação da Torre (recursiva)
    printf("Movimento da Torre:\n");
    moverTorreCima(TORRE_CASAS);
    moverTorreDireita(TORRE_CASAS);

    printf("\n"); // Linha em branco para separar as saídas

    // Movimentação do Bispo (recursiva + loops aninhados)
    printf("Movimento do Bispo:\n");
    moverBispoRecursivo(BISPO_CASAS_VERTICAL, BISPO_CASAS_HORIZONTAL);

    printf("\n");

    // Movimentação da Rainha (recursiva)
    printf("Movimento da Rainha:\n");
    moverRainhaCima(RAINHA_CASAS);
    moverRainhaDireita(RAINHA_CASAS);
    moverRainhaDiagonal(RAINHA_CASAS);

    printf("\n");

    // Movimentação do Cavalo (loops aninhados complexos)
    printf("Movimento do Cavalo:\n");
    moverCavaloLoopsComplexos(CAVALO_CASAS_CIMA, CAVALO_CASAS_DIREITA);

    return 0;
}
